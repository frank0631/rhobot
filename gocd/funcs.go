package gocd

import (
	"bytes"
	"crypto/tls"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"
	"strconv"
	"time"

	log "github.com/Sirupsen/logrus"
)

// GoCDVersionString is the API version string of GoCD for REST calls
const GoCDVersionString = "application/vnd.go.cd.v3+json"

// client returns a http client with longer timeout and skip verify
func client(timeout time.Duration) *http.Client {
	transCfg := &http.Transport{
		TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
	}
	return &http.Client{
		Timeout:   timeout,
		Transport: transCfg,
	}
}

func printPrettyJSON(body []byte, objectname string) (prettyJSON bytes.Buffer, err error) {
	err = json.Indent(&prettyJSON, body, "", "\t")
	if err != nil {
		log.Warn("Failed to prettify JSON: ", err)
	}
	log.Debug(objectname+" JSON:", string(prettyJSON.Bytes()))
	return
}

// readPipelineJSONFromFile reads a GoCD structure from a json file
func readPipelineJSONFromFile(path string) (pipeline Pipeline, err error) {
	data, err := ioutil.ReadFile(path)
	if err == nil {
		err = json.Unmarshal(data, &pipeline)
	}
	return
}

// Partially generated by curl-to-Go: https://mholt.github.io/curl-to-go
func (server Server) pipelineConfigPUT(pipeline Pipeline, etag string) (pipelineResult Pipeline, err error) {

	pipelineName := pipeline.Name

	payloadBytes, err := json.Marshal(pipeline)
	if err != nil {
		return
	}

	payloadBody := bytes.NewReader(payloadBytes)

	req, err := http.NewRequest("PUT", server.URL()+"/go/api/admin/pipelines/"+pipelineName, payloadBody)
	if err != nil {
		return
	}

	if len(server.User) > 0 && len(server.Password) > 0 {
		req.SetBasicAuth(server.User, server.Password)
	}
	req.Header.Set("Accept", GoCDVersionString)
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("If-Match", etag)

	log.Debugf("Sending request: %v", req)
	resp, err := client(server.Timeout).Do(req)
	if err != nil {
		return
	}
	defer resp.Body.Close()

	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return
	}

	if resp.StatusCode != 200 {
		err = fmt.Errorf("Bad response code: %d, response: %s", resp.StatusCode, body)
		return
	}

	printPrettyJSON(body, "pipelineConfig")

	err = json.Unmarshal(body, &pipelineResult)
	return
}

// Generated by curl-to-Go: https://mholt.github.io/curl-to-go
func (server Server) pipelineConfigPOST(pipelineConfig PipelineConfig) (pipeline Pipeline, err error) {
	payloadBytes, err := json.Marshal(pipelineConfig)
	if err != nil {
		return
	}

	payloadBody := bytes.NewReader(payloadBytes)

	req, err := http.NewRequest("POST", server.URL()+"/go/api/admin/pipelines", payloadBody)
	if err != nil {
		return
	}

	if len(server.User) > 0 && len(server.Password) > 0 {
		req.SetBasicAuth(server.User, server.Password)
	}
	req.Header.Set("Accept", GoCDVersionString)
	req.Header.Set("Content-Type", "application/json")

	log.Debugf("Sending request: %v", req)
	resp, err := client(server.Timeout).Do(req)
	if err != nil {
		return
	}
	defer resp.Body.Close()

	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return
	}

	if resp.StatusCode != 200 {
		err = fmt.Errorf("Bad response code: %d with response: %s", resp.StatusCode, body)
		return
	}

	printPrettyJSON(body, "pipelineConfig")

	err = json.Unmarshal(body, &pipeline)
	return
}

// Partially generated by curl-to-Go: https://mholt.github.io/curl-to-go
func (server Server) pipelineGET(pipelineName string) (pipeline Pipeline, etag string, err error) {
	req, err := http.NewRequest("GET", server.URL()+"/go/api/admin/pipelines/"+pipelineName, nil)
	if err != nil {
		return
	}

	if len(server.User) > 0 && len(server.Password) > 0 {
		req.SetBasicAuth(server.User, server.Password)
	}
	req.Header.Set("Accept", GoCDVersionString)
	req.Header.Set("Content-Type", "application/json")

	log.Debugf("Sending request: %v", req)
	resp, err := client(server.Timeout).Do(req)
	if err != nil {
		return
	}
	defer resp.Body.Close()

	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return
	}

	if resp.StatusCode != 200 {
		err = fmt.Errorf("Bad response code: %d with response: %s", resp.StatusCode, body)
		return
	}

	printPrettyJSON(body, "pipelineConfig")

	etag = resp.Header.Get("ETag")
	err = json.Unmarshal(body, &pipeline)
	return
}

// Partially generated by curl-to-Go: https://mholt.github.io/curl-to-go
func (server Server) artifactGET(pipelineName string, pipelineID int, stageName string, stageID int, jobName string, artifactPath string) (fileBytes *bytes.Buffer, err error) {
	reqStr := fmt.Sprintf("%s/go/files/%s/%d/%s/%d/%s/%s/", server.URL(),
		pipelineName, pipelineID, stageName, stageID, jobName, artifactPath)
	req, err := http.NewRequest("GET", reqStr, nil)
	if err != nil {
		return
	}

	if len(server.User) > 0 && len(server.Password) > 0 {
		req.SetBasicAuth(server.User, server.Password)
	}
	req.Header.Set("Content-Type", "application/json")

	log.Debugf("Sending request: %v", req)
	resp, err := client(server.Timeout).Do(req)
	if err != nil {
		return
	}
	defer resp.Body.Close()

	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return
	}

	if resp.StatusCode != 200 {
		err = fmt.Errorf("Bad response code: %d with response: %s", resp.StatusCode, body)
		return
	}

	fileBytes = bytes.NewBuffer(body)
	return
}

// Partially generated by curl-to-Go: https://mholt.github.io/curl-to-go
func (server Server) historyGET(pipelineName string) (latestRuns map[string]int, err error) {
	req, err := http.NewRequest("GET", server.URL()+"/go/api/pipelines/"+pipelineName+"/history", nil)
	if err != nil {
		return
	}

	if len(server.User) > 0 && len(server.Password) > 0 {
		req.SetBasicAuth(server.User, server.Password)
	}
	req.Header.Set("Content-Type", "application/json")

	log.Debugf("Sending request: %v", req)
	resp, err := client(server.Timeout).Do(req)
	if err != nil {
		return
	}
	defer resp.Body.Close()

	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return
	}

	if resp.StatusCode != 200 {
		err = fmt.Errorf("Bad response code: %d with response: %s", resp.StatusCode, body)
		return
	}

	var prettyJSON bytes.Buffer
	err = json.Indent(&prettyJSON, body, "", "\t")
	if err != nil {
		log.Warn("Failed to prettify JSON: ", err)
	}

	log.Debug("pipelineHistory JSON:", string(prettyJSON.Bytes()))

	//Parse JSON to get last run ids from pipeline and stages
	var responseMap map[string]*json.RawMessage
	var pipelineArr []map[string]*json.RawMessage
	var pipelineLatest map[string]*json.RawMessage
	var pipelineCounter int
	var stages []map[string]*json.RawMessage

	_ = json.Unmarshal(body, &responseMap)
	_ = json.Unmarshal(*responseMap["pipelines"], &pipelineArr)
	pipelineLatest = pipelineArr[0]
	_ = json.Unmarshal(*pipelineLatest["counter"], &pipelineCounter)

	latestRuns = make(map[string]int)
	latestRuns["p_"+pipelineName] = pipelineCounter

	_ = json.Unmarshal(*pipelineLatest["stages"], &stages)
	var stageName string
	var stageCounterStr string
	var stageCounterInt int
	for _, stage := range stages {
		_ = json.Unmarshal(*stage["name"], &stageName)
		_ = json.Unmarshal(*stage["counter"], &stageCounterStr)
		stageCounterInt, err = strconv.Atoi(stageCounterStr)
		latestRuns["s_"+stageName] = stageCounterInt
	}

	return
}

// writePipeline helper function to write a pipeline to file
func writePipeline(path string, pipeline Pipeline) (err error) {
	pipelineJSON, _ := json.MarshalIndent(pipeline, "", "    ")
	err = ioutil.WriteFile(path, pipelineJSON, 0666)
	return
}
